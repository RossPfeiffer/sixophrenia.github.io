<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>= EtherSnatch =</title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.0.0-beta.36/dist/web3.min.js" integrity="sha256-nWBTbvxhJgjslRyuAKJHK+XcZPlCnmIAAMixz6EefVk=" crossorigin="anonymous"></script>


</head>
<style>

    *{
        font-family: monospace;
        font-size: 14px;
        font-style: normal;
        font-variant: normal;
        /*font-weight: 500;*/
        line-height: 16px;

    }

    textarea {
        border: none;
        /*overflow: auto;*/
        outline: none;

        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;

        resize: none; /*remove the resize handle on the bottom right*/

        /*resize: none;*/
        overflow: hidden;
        min-height: 15px;
        /*max-height: 100px;*/
    }
    input{
        border: none;
        /*overflow: auto;*/
        outline: none;

        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;

    }

    a{
        outline: none;
        color: inherit; /* blue colors for links too */
        text-decoration: inherit; /* no underline */
    }
    body{

        background-color: black;
        color:white;

        font-family: monospace;
        font-size: 14px;
        font-style: normal;
        font-variant: normal;
        /*font-weight: 500;*/
        line-height: 16px;

        text-align: center;
    }

    p{
        width: 80%;
        margin: 0 auto;
        margin-bottom:14px;
    }

    .frame-double-line{
        padding-top:14px;
        padding-bottom:14px;
    }
    #game{
        display:none;
        padding-top: 56px;

        max-width:800px;
        margin: 0 auto;
    }
    #situation{
        /*display:none;*/
    }
    /*Situation*/
    .game-over{
        margin-top: 28px;
    }
    .option{
        margin: 0 auto;
        margin-top: 14px;
        width: 80%;
    }
    .option:hover{
        background-color: white;
        color:black;
    }
    .situation-text{
        width: 80%;
        margin:0 auto;

        padding-top:14px;
        padding-bottom:14px;
    }
    /*Credit*/
    .credit{
        color: rgba(255,255,255,0.2);
        margin-top: 100px;
        text-align:left;
        /*position: absolute;*/
        /*bottom:0;*/


    }
    .credit:hover{
        color: #00FF00;
    }


    #welcome{
        /*display:none;*/
    }
    .title{
        color: #0F0;
        width:80%;
        margin: 0 auto;
    }
    /*Wecome*/
    .start:hover{

        background-color: white;
        color:black;

    }
    .welcome-link{
        color:#0FF;
    }
    .welcome-link:hover{
        background-color:#0FF;
        color:#000;
    }


    #create{
        /*display:none;*/
    }
    #input-situation{
        width:80%;
        margin: 0 auto;

        /*resize:vertical;*/
        background-color: #222222;
        color:inherit;
        height:15px;
    }
    #input-situation:focus{
        background-color: white;
        color:black;

    }

    .prev-option-selected{
        background-color: white;
        color: black;
        margin: 0 auto;
        width:80%;
    }
    .prev-option{

    }
    .input-button{
        padding-left: 5px;
        padding-right: 5px;

    }
    .input-button:hover{
        background-color: white;
        color:black;
    }
    .input-choice{
        width:80%;

        color:white;
        background-color: #222222;
        font: inherit;
        margin: 0 auto;
        margin-bottom:14px;
    }
    .input-choice:focus{
        background-color: white;
        color:black;
    }
    .input-choice-invalid{
        background-color: #330000;
        color:red;
    }
    .input-choice-invalid:focus{
        color: black;
        background-color: white;
    }

    #input-error{
        color:red;
    }


    #confirm{
        /*display: none;*/
    }
    /* confirm */
    #confirm-button-edit{
        color:orange;
    }
    #confirm-button-edit:hover{
        color:black;
        background-color:orange;
    }

    #confirm-button-submit{
        color:#00CC00;
    }
    #confirm-button-submit:hover{
        background-color:#00CC00;
        color:#000000;
    }


    .button-sign{
        padding-left: 2px;
        padding-right: 2px;
    }
    .button-sign:hover{
        background-color: white;
        color:black;
    }


    .metamask-window-hint{
        color:#00FFFF;

        width: 80%;
        margin:0 auto;

        padding-top:14px;
        padding-bottom:14px;
    }
</style>
<style>
    #measurement{
        position: absolute; top: -100px;
    }
    #withdraw{
      display: none;
    }
    .goldy{
      color:gold;
    }
</style>

<script>
    function resize_textarea(element) {
        // console.log(element);
        element.style.height = "15px";
        element.style.height = (element.scrollHeight)+"px";
    }
</script>
<body>
    <div id="measurement">=</div>

    <div id="game">
        <div id="networkCheck">
            <div class="frame-double-line">====</div>
            <div class="title">
                Error: Please switch to the Ethereum mainnet.
            </div>
            <div class="frame-double-line">====</div>
        </div>
        <div id="welcome">
            <div class="frame-double-line">====</div>

            <div class="title">
               == EtherSNATCH ==
            </div>
            <div class="frame-double-line">====</div>
            <p>
                Every situation and choice in this game has been defined by other writers, and all of it is stored on the Ethereum Blockchain.
                <span id="reminder-metamask">
                    If you use <a id="welcome-button-metamask" class="welcome-link">Metamask</a>, enable it and login now.
                </span>
            </p>
            <p>
                Original Game created by <a href="https://github.com/AnAllergyToAnalogy" class="welcome-link">AnAllergyToAnalogy</a> and forked by <a href="#" class="welcome-link">Econymous</a>, with source code available on
                <a href="https://github.com/AnAllergyToAnalogy/blockchain-adventure" class="welcome-link">GitHub</a>.
            </p>

            <div class="frame-double-line">====</div>
            <a href="" class="control-button" id="start-game">
                <div class="start">
                    << Click Here to Begin! >>
                </div>
            </a><br><br>
            <a href="#" id="cash-out">
                <div id="withdraw">
                    Withdraw Earnings
                    <br><i id="earnings-amount"></i> ETH
                </div>
            </a>
        </div>
        <div id="loading">
            <div>
                Loading data from blockchain...
            </div>
        </div>

        <div id="situation">
            <div class="frame-line">
                ----
            </div>
            <div id="situation-text" class="situation-text">
                You are a magic fish and you live under the sea. Get out of my house you savage. Or else I'm gonna throw some beans at you and then you'll die from bean exposure.
            </div>
            <div class="frame-line">
                ----
            </div>

            <div class="option">Okay Fine</div>
            <div class="option">Never</div>

            <div class="credit">
                <div id="credit-signature">CoolGuy</div>
                <div id="credit-author">0x00000000</div>
            </div>
        </div>


        <div id="create">
            <div class="frame-double-line">====</div>
            <div >Previous situation:</div>
            <div id="create-prev-situation">You are in the forest and millions of ducks are around you trying to destroy your house and you have no friends so now what are you gonna do?</div>
            <div class="frame-line">----</div>

            <div id="create-prev-choices">
                <div>Go into the house</div>
                <div class="prev-option-selected">SELECTED: Buy a new house</div>
                <div>Shoot the mailman</div>
            </div>


            <div class="frame-double-line">====</div>

            <div>The next situation:</div>

            <textarea
                    id="input-situation"

                      onkeyup="resize_textarea(this)"
            ></textarea>
            <div class="frame-line">----</div>
            <div id="input-choices">

            </div>

            <div>
                <span class="input-button" id="input-add-choice">Add a Choice</span> |
                <span class="input-button" id="input-submit-situation">Submit Situation</span>
            </div>
            <div id="input-error">
                This is the problem with your situation!
            </div>
        </div>

        <div id="confirm">
            <div class="frame-double-line">====</div>
            <div>You are about to create this situation:</div>
            <div class="frame-double-line">====</div>
            <div id="confirm-situation">You are in the forest and millions of ducks are around you trying to destroy your house and you have no friends so now what are you gonna do?</div>
            <div class="frame-line">----</div>
            <div id="confirm-choices">

            </div>

            <div class="frame-double-line">====</div>

            <div>
                <span id="confirm-button-edit">Change something</span> |
                <span id="confirm-button-submit">Submit it!</span>
            </div>

            <div class = "metamask-window-hint" > (Clicking submit will open a Metamask transaction window. You may have to look for it in the top-righthand side of the screen, or click the little fox icon.) </div>

        </div>

        <div id="wait">
            <div class="frame-line">----</div>
            <div class="situation-text">
                A transaction has been made with your new situation.
            </div>
            <div class="situation-text">
                You can stick around here and wait for it to be confirmed and you'll automatically be brought to the situation you just created (it will take about 20 seconds),
                or you can go back to the start of the game and play again.
            </div>
                <div class="situation-text">
                You can also sign your name and it'll be added to any of the situations you've created (you can resume the story afterwards).
            </div>
            <div class="frame-line">----</div>

            <div id="wait-restart" class="option">Back to the start</div>
            <div id="wait-sign" class="option">Add signature</div>

        </div>

        <div id="sign">
            <div class="frame-double-line">====</div>

            <div>Enter your name below to sign your contributions:</div>
            <div class="frame-line">----</div>
            <input class="input-choice" id="input-signature"/>
            <div>
                <span class="button-sign" id="sign-button-cancel">Never mind</span> |
                <span class="button-sign" id="sign-button-submit">Sign</span>
            </div>
            <div class = "metamask-window-hint"> (Clicking submit will open a Metamask transaction window. You may have to look for it in the top-righthand side of the screen, or click the little fox icon.) </div>
            <div class="frame-double-line">====</div>
        </div>

        <div id="signConfirm">
            <div class="frame-double-line">====</div>
            <div> Thankyou, <span id="thanks-signature"></span>, a transaction with your signature has been sent. If you wait here you'll automatically be brought to your situation when it's added to the blockchain in a few seconds. Otherwise you can go back to the start of the game.</div>
            <div class="frame-double-line">====</div>

            <div class="option" id="sign-confirm-restart"> - Restart Game - </div>
        </div>

        <div id="learn">
            <div class="frame-double-line">====</div>
                <div class="title">What is Metamask?</div>

            <div class="frame-double-line">====</div>
                <p><a href="https://metamask.io/" class="welcome-link">Metamask</a> is a browser extension that lets you interact with the Ethereum blockchain. It works with most popular browsers (except for Safari because that's made by contrarian hipsters). </p>
                <p>If you want to read data from the blockchain, it won't cost you anything, but if you want to add data, or make any other changes to the network, you have to pay a bit of Ether (ETH). It will only cost a few cents in real money.</p>
                <p>This Ether is given to miners, and is their reward for running this decentralised network on their computers. The miners can't modify your data, control what you do, or steal your Ether, you're basically just paying them a little bit to borrow some of the computer power.</p>

                <p>Once you have Metamask installed, you'll need to get your hands on some Ether. If you don't know where to get it, just ask your nerdiest friend where to buy cryptocurrency.</p>

                <p>Then you're all set. When you reach a point in the game where the story is incomplete, the game will let you write your own contribution and Metamask will take care of all the technical stuff. You don't need to know anything about coding or blockchains.</p>
            <div class="frame-line">----</div>

            <div class="option" id="learn-button-restart"> Cool, take me back to the game </div>
            <div>&nbsp;</div>
            <div class="frame-line">----</div>
        </div>

    </div>
</body>
<script>
var NETWORK = "1"
function Game(container,contract){
    let game = {
        screens: {
            networkCheck:      ById("networkCheck"),

            welcome:      ById("welcome"),
            situation:    ById("situation"),
            loading:      ById("loading"),
            create:       ById("create"),
            confirm:      ById("confirm"),
            wait:         ById("wait"),
            sign:         ById("sign"),
            signConfirm:  ById("signConfirm"),

            learn:        ById("learn"),
        },
        create:{
              fromSituation: 0,
                fromChoice: 0,

            situationText: '',
            choices: [],
            choiceFields: [],

            closable: false,

            submit: () =>{
                //parse the input
                SetText(ById("input-error"),"");

                if(game.create.situationText.trim() === ""){
                    SetText(ById("input-error"),
                        "Error: your situation text is empty"
                    );
                    return;
                }
                for(let c = 0; c < game.create.choiceFields.length; c++){
                    let field = game.create.choiceFields[c];
                    if(field.value.length > 32){
                        SetText(ById("input-error"),
                            "Error: your choice is too long (32 char max)"
                        );
                        field.setAttribute("class","input-choice input-choice-invalid");
                        return;
                    }
                }

                if(!game.create.closable && game.create.choiceFields.length === 0){
                    SetText(ById("input-error"),
                        "Error: this is the last open pathway, so you must provide at least one choice."
                    );
                    return;
                }
                game.open_confirm();
            },
            reset: () => {
                ById("input-situation").value = "";
                game.create.choices = [];
                game.create.choiceFields.forEach( field => {
                    ById("input-choices").removeChild(field);
                });
                game.create.choiceFields = [];
            },
            add_choice: () =>{
                let input = document.createElement('INPUT');
                input.setAttribute("type","text");
                input.setAttribute("class","input-choice");

                input.addEventListener("change", event => {
                    game.create.read_choices(false);
                    event.target.setAttribute("class","input-choice");
                    SetText(ById("input-error"),"");
                });
                input.addEventListener("blur", event => {
                    game.create.read_choices(true);
                });

                game.create.choiceFields.push(input);
                ById("input-choices").appendChild(input);
                input.focus();
            },
            read_choices: (doClear) => {
                let choices = [];
                for(let i = 0; i < game.create.choiceFields.length; i++){
                    let field = game.create.choiceFields[i];
                    let value = field.value.trim();
                   if( value !== ""){
                        choices.push(value);
                   }else if(doClear){
                        ById("input-choices").removeChild(field);
                        game.create.choiceFields.splice(i--,1);
                   }
                };
                game.create.choices = choices;
            },
        },
        confirm: {
            submit: async () => {
                let transaction = await contract.add_situation(
                  game.create.fromSituation,
                  game.create.fromChoice,
                    game.create.situationText,
                    game.create.choices,
                    (transaction) => {
                        if(transaction.accepted){
                            game.wait.hash = transaction.hash;
                            game.wait.fromSituation = game.create.fromSituation;
                            game.wait.fromChoice    = game.create.fromChoice;
                            game.open_wait();
                        }
                    }
                );
            }
        },
        wait: {
            fromSituation: 0,
            fromChoice: 0,
            hash: '',
            interval: null,
            doWait: () => {
                //getting tx receipt doesn't actually matter, it's just the next situation being available which will happen as a result anyway,
                // or if someone else defines it
                game.wait.interval = setInterval( async () => {
                    const next = await contract.get_next_situation(game.wait.fromSituation,game.wait.fromChoice);
                    if(String(next[0]) !== '0'){
                        clearInterval(game.wait.interval);
                        game.goto_next_situation(game.wait.fromSituation,game.wait.fromChoice);
                    }
                }, 1000);//doWaitThing
            }
        },
        sign: {
              signature: '',
            submit: async() =>{
                let transaction = await contract.add_signature(
                    game.sign.signature,
                    (transaction) => {
                        if(transaction.accepted){
                            game.open_signConfirm();
                        }
                    }
                );

            }
        },
        path:[],
        breadCrumbs: {now:0,last:0},

        reveals: (elements /*array*/) => {
              for(let i = 0; i < elements.length; i++){
                Show(elements[i],false);
                setTimeout(()=>{
                    Show(elements[i],true);
                }, (i + 1) * 50);
              }
        },

        init: () => {
            RedrawFrames();
            window.addEventListener('resize', ()=>{
                RedrawFrames();
            });


            //Start page
            onClick(ById("start-game"),async ()=>{
                game.open_situation(0);

                //Hacky last chance way of checking they aren't entering on wrong network
                // let network = await web3.eth.net.getId();
                // if(String(network) !== '4'){ //main: 1
                //     location.reload();
                // }
            });

            ById("input-situation").addEventListener("change", event => {
                game.create.situationText = event.target.value.trim();
                SetText(ById("input-error"),"");
            });


            onClick(ById("welcome-button-metamask"), ()=>{
                game.open_learn();
            });



            //Buttons wait
            onClick(ById("wait-sign"), ()=>{
                clearInterval(game.wait.interval);
                game.open_sign();
            });
            onClick(ById("wait-restart"),()=>{
                clearInterval(game.wait.interval);
               game.start();
            });

            onClick(ById("input-add-choice"),()=>{
                game.create.add_choice();
            });
            onClick(ById("input-submit-situation"), ()=>{
                game.create.submit();
            });

            onClick(ById('confirm-button-edit'), () =>{
                game.show_screen(false);
                let screen_elements = game.screens.create.children;
                game.reveals(screen_elements);

                game.show_screen('create');
            });
            onClick(ById('confirm-button-submit'), () =>{
                game.confirm.submit();
            });


            //Signature
            ById("input-signature").addEventListener("change", event => {
                game.sign.signature = event.target.value;
            });
            onClick(ById("sign-button-cancel"),()=>{
                game.start();
            });
            onClick(ById("sign-button-submit"), ()=>{
                game.sign.submit();
            });


            onClick(ById("sign-confirm-restart"), () =>{
                clearInterval(game.wait.interval);
                game.start();
            });

            //Learn
            onClick(ById("learn-button-restart"), () =>{
               game.start();
            });
        },

        show_screen: (screen) => {
              for(let s in game.screens){
                  Show(game.screens[s],s === screen);
              }
        },
        start: async () => {
              game.path = [0]
              if(!contract.check_network()){
                    let network = await web3.eth.net.getId();
                    if(String(network) !== NETWORK){
                        setTimeout(()=> {
                            container.style.display = "inherit";
                            game.show_screen("networkCheck");

                            let screen_elements = game.screens.networkCheck.children;
                            game.reveals(screen_elements);
                        },200);
                        return;
                    }
              }

              setTimeout( async ()=>{
                  container.style.display = "inherit";
                  game.show_screen("welcome");

                  Show(ById("reminder-metamask"),!contract.check_metamask());

                  earnings = await contract.get_earnings()
                  console.log('How much you\'ve earned',earnings)
                  ById("earnings-amount").innerHTML = (earnings/1000000000000000000).toFixed(4)
                  let wEl = ById("withdraw");
                  Show(wEl,earnings>0)
                  onClick(wEl,contract.pull_earnings)

                  let screen_elements = game.screens.welcome.children;
                  game.reveals(screen_elements);
              },200);
        },

        open_create: async(from_situation,from_choice) => {


          game.create.fromSituation = from_situation;
          game.create.fromChoice = from_choice;

            game.create.reset();
            game.show_screen("loading");

            let previous_situation = {found:false};
            while(!previous_situation.found){
                //Endless loop for load fails.. no way that can go badly
                previous_situation = await contract.get_situation(from_situation);

            }
            SetText(ById('create-prev-situation'),previous_situation.situationText);


            SetText(ById("input-error"),"");

            let prevChoices = ById('create-prev-choices');
            prevChoices.innerHTML = '';
            for(let i = 0; i < previous_situation.choiceText.length; i++){
                prevChoices.appendChild(
                    PrevChoice(previous_situation.choiceText[i],String(i) === String(from_choice))
                )
            }

            let screen_elements = game.screens.create.children;
            game.reveals(screen_elements);

            game.show_screen('create');

            game.create.closable = await contract.get_closable();
        },
        open_confirm: () => {
            game.show_screen(false);
              SetText(ById("confirm-situation"),game.create.situationText);
              if(game.create.choices.length > 0){
                  ById('confirm-choices').innerHTML = '';
                  game.create.choices.forEach( choice => {
                      ById('confirm-choices').appendChild(
                          PrevChoice(choice,false)
                      );
                  });
              }else{
                  SetText(ById('confirm-choices'),"Note: you haven't provided any choices. This means the game will end when players arrive at this point.");
              }
            let screen_elements = game.screens.confirm.children;
            game.reveals(screen_elements);

          game.show_screen('confirm');
        },

        open_learn: () => {
            game.show_screen(false);
            let screen_elements = game.screens.learn.children;
            game.reveals(screen_elements);

            game.show_screen('learn');
        },

        open_wait: () => {
            game.show_screen(false);
            let screen_elements = game.screens.wait.children;
            game.reveals(screen_elements);

            game.show_screen('wait');

            // game.wait.interval = setInterval( async ()=> {
            //     if(await web3.eth.getTransactionReceipt(game.wait.hash)){
            //         //Returns null until it returns the object below
            //         clearInterval(game.wait.interval);
            //     };
            // },1000);

            game.wait.doWait();
        },
        open_sign: () => {
              game.sign.signature = '';
            ById("input-signature").value = '';
            game.show_screen(false);
            let screen_elements = game.screens.sign.children;
            game.reveals(screen_elements);

            game.show_screen('sign');
        },
        open_signConfirm: () => {

            game.show_screen(false);
            let screen_elements = game.screens.signConfirm.children;
            game.reveals(screen_elements);
            SetText(ById("thanks-signature"),game.sign.signature);

            game.show_screen('signConfirm');

            game.wait.doWait();
        },

        open_situation: async (id) => {
            game.show_screen("loading");

            ById('situation-text').style.color = "#FFFFFF";

            let situation = {found:false};
            while(!situation.found){
                //Endless loop for load fails.. no way that can go badly
                situation = await contract.get_situation(id);
            }

            game.show_screen(false);
            //Clear Choices
            while(game.screens.situation.children.length > 4){
                let length = game.screens.situation.children.length;
                game.screens.situation.removeChild(
                    game.screens.situation.children[length - 2]
                )
            }
            //Add new choices

            for( let i = 0; i < situation.choiceText.length; i++){
                let choice_label = situation.choiceText[i];
                let length = game.screens.situation.children.length;
                let newOption = Option(choice_label);
                onClick(newOption,()=>{
                    game.goto_next_situation(id,i);
                });
                game.screens.situation.insertBefore(
                    newOption,
                    game.screens.situation.children[length - 1]
                );
            }
            if(situation.choiceText.length === 0){
                game.screens.situation.insertBefore(
                    GameOver(),
                    game.screens.situation.children[3]
                );
                let play_again = Option("Play again?");
                onClick(play_again,game.start);
                game.screens.situation.insertBefore(
                    play_again,
                    game.screens.situation.children[4]
                );
                let go_back  = Option("Take me back to the last situation");
                onClick(go_back,()=>{game.open_situation(game.breadCrumbs.last)});
                game.screens.situation.insertBefore(
                    go_back,
                    game.screens.situation.children[5]
                );
            }


            game.show_screen('situation');

                SetText(ById('situation-text'),situation.situationText);

            SetText(ById('credit-signature'),"");
            SetText(ById('credit-author'),  "");


              let screen_elements = game.screens.situation.children;
              game.reveals(screen_elements);


            let signature = await contract.get_signature(id);
            SetText(ById('credit-signature'),signature);
            let author = await contract.get_author(id);
            SetText(ById('credit-author'),author);
        },
        prompt_situation_creation: async(from_situation, from_choice) =>{
            game.show_screen(false);

            let metamasked = contract.check_metamask();

            if(metamasked){
                SetText(ById('situation-text'),
                    "It looks like nobody has decided what happens next... yet. But don't despair! You can go back to the previous situation, or if you're feeling creative, add to the story."
                );
            }else{
                SetText(ById('situation-text'),
                    "It looks like nobody has decided what happens next... yet. But don't despair! You can go back to the previous situation, or if you enable MetaMask, add to the story."
                );
            }

            ById('situation-text').style.color = "#00ffff";

            let author = "";
            let signature = "";

            //Clear Choices
            while(game.screens.situation.children.length > 4){
                let length = game.screens.situation.children.length;
                game.screens.situation.removeChild(
                    game.screens.situation.children[length - 2]
                )
            }

            let c = 3;

            //Add new choices
            let go_back  = Option("Take me back to the last situation");
            onClick(go_back,()=>{game.open_situation(from_situation)});
            game.screens.situation.insertBefore(
                go_back,
                game.screens.situation.children[c++]
            );

            if(metamasked){
                let add_situation = Option("Add to the story");
                onClick(add_situation,()=>{
                    game.open_create(from_situation,from_choice);
                });
                game.screens.situation.insertBefore(
                    add_situation,
                    game.screens.situation.children[c++]
                );
            }else{
                let add_situation = Option("Learn about Metamask");
                onClick(add_situation,()=>{
                    game.open_learn();
                });
                game.screens.situation.insertBefore(
                    add_situation,
                    game.screens.situation.children[c++]
                );
            }


            let play_again = Option("Start the game again");
            onClick(play_again,game.start);
            game.screens.situation.insertBefore(
                play_again,
                game.screens.situation.children[c++]
            )


            let mineableGoldData
            console.log("Game path",game.path)
            /*async () => { */
            mineableGoldData = await contract.see_gold(game.path)
            //} ;
            let estimatedGold = 0
            for(let i = 0;i<game.path.length;i+=1){
              let gold = mineableGoldData[0][i]
              let div = mineableGoldData[1][i]
              estimatedGold += (gold-(gold/div))/div
            }
            let formattedGold = (estimatedGold/1000000000000000000).toFixed(4)

            let collect_gold = Option("Mine "+formattedGold+" ETH");
            collect_gold.className ="goldy"
            collect_gold.id = "gold-mine"
            onClick(collect_gold,game.collect_gold);
            game.screens.situation.insertBefore(
                collect_gold,
                game.screens.situation.children[c++]
            )

            game.show_screen('situation');


            SetText(ById('credit-signature'),signature);
            SetText(ById('credit-author'),author);

            let screen_elements = game.screens.situation.children;
            game.reveals(screen_elements);
        },
        goto_next_situation: async (from_situation, from_choice) => {
            game.show_screen("loading");
            let next_situation_data = await contract.get_next_situation(from_situation,from_choice);
            let next_situation = next_situation_data[0]
            console.log("What is the next situation?",next_situation)
            if(next_situation !== '0'){
                game.breadCrumbs.last = game.breadCrumbs.now;
                game.path.push(next_situation)
                game.breadCrumbs.now = next_situation;
                game.open_situation(next_situation);
            }else{
                game.prompt_situation_creation(from_situation,from_choice);
            }
        },
        collect_gold: async () => {
            let collectedGold = await contract.mine_gold(game.path);
        }
    };
    game.init();
    game.start();
    return game;

    function onClick(element, action){
        element.addEventListener("click", function(event){
            event.preventDefault();
            action();
        });
    }
    function Show(element,onOff){
        if(onOff){
            element.style.display = "block";
        }else{
            element.style.display = "none";
        }
    }
    function ById(id){
        return document.getElementById(id);
    }
    function SetText(element,text){
        element.innerText = text;
    }
    function Option(option_text){
        let a = document.createElement('A');
        a.setAttribute("href","");
        let div = document.createElement("DIV");
        div.setAttribute("class","option");
        div.innerText = option_text;
        a.appendChild(div);
        return a;
    }

    function PrevChoice(choice_text,selected){
        let div = document.createElement("DIV");
        if(selected){
            div.setAttribute("class","prev-option-selected");
            choice_text = "SELECTED: "+choice_text;
        }
        div.innerText = choice_text;
        return div;
    }

    function GameOver(){
        let div = document.createElement("DIV");
        div.setAttribute("class","game-over");
        div.innerText = " - Game over - ";
        return div;
    }

    function RedrawFrames(){
        const width = Math.min(800,window.innerWidth);

        const chars = Math.floor(width /ById("measurement").clientWidth * 0.75);

        let singleLine = "";
        let doubleLine = "";
        for(let c = 0; c < chars; c++){
            singleLine += "-";
            doubleLine += "=";
        }

        let singleLines = document.getElementsByClassName("frame-line");
        for(let l = 0; l < singleLines.length; l++){
            singleLines[l].innerText = singleLine;
        }
        let doubleLines = document.getElementsByClassName("frame-double-line");
        for(let l = 0; l < doubleLines.length; l++){
            doubleLines[l].innerText = doubleLine;
        }
    }
}
const Contract  = () => {
    if (typeof web3 !== 'undefined') {
        // console.log('no web3');
        web3 = new Web3(web3.currentProvider);
    } else {
        let provider;
        if(window.ethereum){
            provider = window.ethereum;

        }else{
            // provider = new Web3.providers.HttpProvider("https://rinkeby.infura.io/ig6kT98jxZiw5QM7QTRn");
            provider = new Web3.providers.HttpProvider("https://mainnet.infura.io/ig6kT98jxZiw5QM7QTRn");
        }
        web3 = new Web3(provider);

    }

    const address = "0x550c71d75562a014511d9e0de9c75aa0dc3759fd";    //Mainnet
    const compiled = {
        "Adventure": {
            "abi":[
                    	{
                    		"constant": false,
                    		"inputs": [
                    			{
                    				"name": "signature",
                    				"type": "string"
                    			}
                    		],
                    		"name": "add_signature",
                    		"outputs": [],
                    		"payable": false,
                    		"stateMutability": "nonpayable",
                    		"type": "function"
                    	},
                    	{
                    		"constant": false,
                    		"inputs": [
                    			{
                    				"name": "fromSituation",
                    				"type": "uint256"
                    			},
                    			{
                    				"name": "fromChoice",
                    				"type": "uint256"
                    			},
                    			{
                    				"name": "situationText",
                    				"type": "string"
                    			},
                    			{
                    				"name": "choiceTexts",
                    				"type": "bytes32[]"
                    			}
                    		],
                    		"name": "add_situation",
                    		"outputs": [],
                    		"payable": true,
                    		"stateMutability": "payable",
                    		"type": "function"
                    	},
                    	{
                    		"constant": false,
                    		"inputs": [
                    			{
                    				"name": "situations",
                    				"type": "uint256[]"
                    			}
                    		],
                    		"name": "mine_gold",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "nonpayable",
                    		"type": "function"
                    	},
                    	{
                    		"constant": false,
                    		"inputs": [],
                    		"name": "pull_earnings",
                    		"outputs": [],
                    		"payable": false,
                    		"stateMutability": "nonpayable",
                    		"type": "function"
                    	},
                    	{
                    		"inputs": [
                    			{
                    				"name": "situationText",
                    				"type": "string"
                    			},
                    			{
                    				"name": "choiceTexts",
                    				"type": "bytes32[]"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "nonpayable",
                    		"type": "constructor"
                    	},
                    	{
                    		"anonymous": false,
                    		"inputs": [
                    			{
                    				"indexed": true,
                    				"name": "id",
                    				"type": "uint256"
                    			},
                    			{
                    				"indexed": false,
                    				"name": "situationText",
                    				"type": "string"
                    			},
                    			{
                    				"indexed": false,
                    				"name": "choiceTexts",
                    				"type": "bytes32[]"
                    			}
                    		],
                    		"name": "Situation",
                    		"type": "event"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "situation",
                    				"type": "uint256"
                    			}
                    		],
                    		"name": "get_author",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "address"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "author",
                    				"type": "address"
                    			}
                    		],
                    		"name": "get_earnings",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "fromSituation",
                    				"type": "uint256"
                    			},
                    			{
                    				"name": "fromChoice",
                    				"type": "uint256"
                    			}
                    		],
                    		"name": "get_next_situation",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			},
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [],
                    		"name": "get_pathwayCount",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "situation",
                    				"type": "uint256"
                    			}
                    		],
                    		"name": "get_signature",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "string"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"name": "gold",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	},
                    	{
                    		"constant": true,
                    		"inputs": [
                    			{
                    				"name": "situations",
                    				"type": "uint256[]"
                    			}
                    		],
                    		"name": "see_gold",
                    		"outputs": [
                    			{
                    				"name": "",
                    				"type": "uint256[]"
                    			},
                    			{
                    				"name": "",
                    				"type": "uint256[]"
                    			}
                    		],
                    		"payable": false,
                    		"stateMutability": "view",
                    		"type": "function"
                    	}
                    ]
          }
    };


    const abi = compiled.Adventure.abi;
    let abi_array = [];
    for(let i in abi){
        abi_array.push(abi[i]);
    }
    //const bytecode = compiled.Adventure.evm.bytecode.object;

    let instance = new web3.eth.Contract(
        abi_array,
        address
    );

    let account, network;
    let contract = {
        check_metamask: () => {
            return account !== "0x0";
        },
        check_network: () => {
            return String(network) === NETWORK;  //ropsten/Mainnet
        },

        init: async () => {
            await contract.get_account();
            network = await web3.eth.net.getId();
        },
        get_account: async () => {
            web3.eth.getAccounts().then((accounts) => {
                if(accounts.length > 0){
                    account = accounts[0];
                    console.log("got account");
                    console.log(accounts[0]);
                }else{
                    //No metamask
                    console.log('account set to 0x0');
                    account = "0x0";
                }
            }).catch((e) => {
                console.log('get account failed');
            });
        },

        get_situation: async (id) => {
            const situation = await instance.getPastEvents("Situation", {
                filter: {id: [id]},
                fromBlock: 7073631,
                toBlock: 'latest'
            }).then(events => {
                return {
                    found: true,
                    situationText: events[0].returnValues.situationText,
                    choiceText: DeChoices(events[0].returnValues.choiceTexts)
                }
            }).catch(error => {
                console.log('failed to get situation',error);
                return {
                    found: false,
                    error: error,
                }
            });

            return situation;
        },
        get_signature: async (situation) => {
            return await instance.methods.get_signature(situation).call();
        },
        get_author: async (situation) => {
            return await instance.methods.get_author(situation).call();
        },
        get_closable: async () =>{
            let pathwayCount = await instance.methods.get_pathwayCount().call();
            return (String(pathwayCount) !== '1');
        },
        get_next_situation: async (fromSituation, fromChoice) => {
            return await instance.methods.get_next_situation(fromSituation, fromChoice).call();
        },
        get_earnings: async () => {
            return await instance.methods.get_earnings(account).call();
        },
        see_gold: async (paths) => {
            return await instance.methods.see_gold(paths).call();
        },
        pull_earnings: async () => {
            //TODO: get the callback,
            try{
                let toSend = instance.methods.pull_earnings();
                web3.eth.sendTransaction({
                    from: account,
                    to: address,
                    data:toSend.encodeABI()
                },(err,hash)=>{
                    /*callback({
                        accepted: !err,
                        hash: hash
                    });*/
                });

                console.log('pull_earnings tx sent');
            }catch(err){
                console.log('pull_earnings tx failed');
            }
            return {
                accepted: true,
                hash: '0x0'
            }
        },
        mine_gold: async (paths) => {
            //TODO: get the callback,
            try{
                let toSend = instance.methods.mine_gold( paths.reverse() );
                web3.eth.sendTransaction({
                    from: account,
                    to: address,
                    data:toSend.encodeABI()
                },(err,hash)=>{
                    /*callback({
                        accepted: !err,
                        hash: hash
                    });*/
                });

                console.log('mining tx sent');
            }catch(err){
                console.log('mining tx failed');
            }
            return {
                accepted: true,
                hash: '0x0'
            }
        },
        add_situation: (fromSituation, fromChoice, situationText, choiceTexts, callback) => {
            //TODO: get the callback,
            try{
                let leChoices = Choices(choiceTexts)
                console.log("le Choices",leChoices)
                let toSend = instance.methods.add_situation(fromSituation, fromChoice, situationText, leChoices);

                web3.eth.sendTransaction({
                    from: account,
                    to: address,
                    data:toSend.encodeABI(),
                    value:4000000000000000
                },(err,hash)=>{
                    callback({
                        accepted: !err,
                        hash: hash
                    });
                });

                console.log('tx sent');
            }catch(err){
                console.log('tx failed');
            }
            return {
                accepted: true,
                hash: '0x0'
            }
        },
        add_signature: (signature,callback) => {
            let toSend = instance.methods.add_signature(signature);
            // let tx = toSend.send({
            //     from:account
            // });

            web3.eth.sendTransaction({
                from: account,
                to: address,
                data:toSend.encodeABI()
            },(err,hash)=>{
                callback({
                   accepted: !err,
                   hash: hash
                });
            });


            // return {
            //     accepted: true,
            //     hash: '0x0',
            // }
        },
    }
    contract.init();

    function Choice(choiceText){
        return web3.utils.fromAscii(choiceText);
    }
    function Choices(choiceTexts){
        let choices = [];
        choiceTexts.forEach( choiceText =>{
            choices.push(Choice(choiceText));
        });
        return choices;
    }
    function DeChoice(choiceText){
        let converted = web3.utils.toAscii(choiceText);
        converted = converted.replace(/\u0000/g, '');
        return converted;
    }
    function DeChoices(choiceTexts){
        let choices = [];
        choiceTexts.forEach( choiceText =>{
            choices.push(DeChoice(choiceText));
        });
        return choices;
    }
    return contract;


}


    (Game(
        document.getElementById("game"),
        Contract()
    ));
</script>
</html>
